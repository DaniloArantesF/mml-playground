<m-group id="maze"> </m-group>

<script>
  const mazeContainer = document.getElementById("maze");
  const defaultDoorSound = "https://files.daarfi.me/hl-door-sound.mp3";

  const directions = [
    [1, 0],
    [0, -1],
    [-1, 0],
    [0, 1],
  ];

  class Door {
    constructor(cell, wallIndex) {
      this.doorElement = document.createElement("m-cube");
      this.id = `${cell.row}:${cell.column}:${wallIndex}`;

      const width = wallIndex % 2 === 0 ? Cell.cellSize + Cell.wallWidth / 2 : Cell.wallWidth;
      const depth = wallIndex % 2 !== 0 ? Cell.cellSize + Cell.wallDepth / 2 : Cell.wallDepth;

      const offset = directions[wallIndex];
      const x = cell.position.x + offset[1] * (Cell.cellSize / 2 + Cell.wallWidth / 2);
      const z = cell.position.z + offset[0] * (Cell.cellSize / 2 + Cell.wallDepth / 2);

      this.doorElement.setAttribute("id", this.id);
      this.doorElement.setAttribute("width", width);
      this.doorElement.setAttribute("height", Cell.wallHeight + 0.001);
      this.doorElement.setAttribute("depth", depth);

      this.doorElement.setAttribute("x", x);
      this.doorElement.setAttribute("y", cell.position.y + Cell.wallHeight / 2);
      this.doorElement.setAttribute("z", z);

      this.doorElement.setAttribute("color", "#000000");

      // open label
      // const label = document.createElement("m-label");
      // label.setAttribute("x", offset[1] * 0.5);
      // label.setAttribute("y", 0.5);
      // label.setAttribute("z", offset[0] * 0.5);
      // label.setAttribute("content", "Open");
      // label.setAttribute("width", "1");
      // label.setAttribute("height", ".5");
      // label.setAttribute("rx", "0");
      // label.setAttribute(
      //   "ry",
      //   `${wallIndex % 2 === 0 ? (wallIndex === 0 ? 0 : 1) * 180 : offset[1] * 90}`,
      // );

      // label.setAttribute("onclick", `openDoor("${this.id}")`);
      // this.doorElement.appendChild(label);

      // Create sound tag
      this.audio = document.createElement("m-audio");
      this.audio.setAttribute("src", defaultDoorSound);
      this.audio.setAttribute("volume", "0.5");
      this.audio.setAttribute("autoplay", "false");
      this.audio.setAttribute("loop", "false");
      this.audio.setAttribute("enabled", "false");
      this.audio.setAttribute("debug", "true");

      this.doorElement.appendChild(this.audio);
      mazeContainer.appendChild(this.doorElement);

      // const positionProbe = document.getElementById('maze-position-probe');
      // console.log(`Door position:  x: ${x} | z: ${z}`);
      // positionProbe.addEventListener('positionmove', (event) => {
      //   console.log(event.detail.documentRelative);
      // });

      this.setupPositionProbe();

      this.state = {
        animationInterval: null,
      }
    }

    setupPositionProbe() {
      // Create position probe
      this.probe = document.createElement("m-position-probe");
      this.probe.setAttribute("id", `${this.id}-probe`);
      this.probe.setAttribute("x", this.doorElement.getAttribute("x"));
      this.probe.setAttribute("y", this.doorElement.getAttribute("y"));
      this.probe.setAttribute("z", this.doorElement.getAttribute("z"));
      this.probe.setAttribute("range", Cell.cellSize);
      this.probe.setAttribute("interval", "200");
      this.probe.setAttribute("debug", "true");
      this.doorElement.parentNode.appendChild(this.probe);

      // Handle events
      this.probe.addEventListener("positionenter", (event) => {
        this.openDoor();
      });

      this.probe.addEventListener("positionleave", (event) => {
        this.closeDoor();
      });
    }

    clearAnimationInterval() {
      if (this.state.animationInterval) {
        clearInterval(this.state.animationInterval);
        this.state.animationInterval = null;
      }
    }

    openDoor() {
      const y = this.doorElement.getAttribute("y");
      const doorAudio = this.audio;
      doorAudio.setAttribute("enabled", "true");
      doorAudio.setAttribute("start-time", document.timeline.currentTime);

      this.clearAnimationInterval();

      this.state.animationInterval = setInterval(() => {
        const newY = parseFloat(this.doorElement.getAttribute("y")) - 0.2;
        this.doorElement.setAttribute("y", newY);
        if (newY <= -Cell.wallHeight) {
          doorAudio.setAttribute("enabled", "false");
          clearInterval(this.state.animationInterval);
          this.state.animationInterval = null;
        }
      }, 100);
    }

    closeDoor() {
      const y = Cell.wallHeight / 2;// + 0.0001;
      const doorAudio = this.audio;
      doorAudio.setAttribute("enabled", "true");
      doorAudio.setAttribute("start-time", document.timeline.currentTime);

      this.clearAnimationInterval();

      this.state.animationInterval = setInterval(() => {
        const newY = parseFloat(this.doorElement.getAttribute("y")) + 0.2;
        this.doorElement.setAttribute("y", newY);
        if (newY >= y) {
          clearInterval(this.state.animationInterval);
          this.state.animationInterval = null;
        }
      }, 100);
    }
  }

  class Cell {
    static cellSize = 3;
    static wallWidth = 0.5;
    static wallDepth = 0.5;
    static wallHeight = 3;

    constructor(row, column) {
      this.row = row;
      this.column = column;
      this.walls = [true, true, true, true];
      this.visited = false;
      this.position = Cell.getPosition(row, column);
      this.doors = {};
    }

    // returns the position of the center of the cell in the world
    static getPosition(row, col) {
      return {
        x: ((2 * col + 1) * Cell.cellSize) / 2 + col * Cell.wallWidth,
        y: 0,
        z: ((2 * row + 1) * Cell.cellSize) / 2 + row * Cell.wallDepth,
      };
    }

    spawnCellWalls() {
      const colors = ["red", "green", "blue", "yellow"];
      for (let i = 0; i < 4; i++) {
        if (this.walls[i]) {
          const wall = document.createElement("m-cube");
          wall.setAttribute(
            "x",
            this.position.x +
              (directions[i][1] * Cell.cellSize) / 2 +
              (directions[i][1] * Cell.wallWidth) / 2,
          );
          wall.setAttribute("y", Cell.wallHeight / 2);
          wall.setAttribute(
            "z",
            this.position.z +
              (directions[i][0] * Cell.cellSize) / 2 +
              (directions[i][0] * Cell.wallDepth) / 2,
          );

          wall.setAttribute("color", "gray");

          wall.setAttribute(
            "sx",
            directions[i][1] === 0 ? Cell.cellSize + Cell.wallWidth : Cell.wallWidth,
          );
          wall.setAttribute("sy", Cell.wallHeight);
          wall.setAttribute(
            "sz",
            directions[i][0] === 0 ? Cell.cellSize + Cell.wallDepth : Cell.wallDepth,
          );

          mazeContainer.appendChild(wall);
        }
      }
    }

    spawnCellLabel() {
      const label = document.createElement("m-label");
      label.setAttribute("x", this.position.x);
      label.setAttribute("y", this.position.y + 0.1);
      label.setAttribute("z", this.position.z);
      label.setAttribute("content", `(y:${this.row}, x: ${this.column})`);
      label.setAttribute("width", "2");
      label.setAttribute("rx", "-90");
      mazeContainer.appendChild(label);
    }

    createDoor(wallIndex) {
      this.walls[wallIndex] = false;
      const door = new Door(this, wallIndex);
      this.doors[door.id] = door;
    }
  }

  class Maze {
    constructor() {
      this.gridSize = 10;
      this.grid = [];
      this.createGrid();
      this.createPositionProbe();

      this.currentCell = this.grid[0][0];

      // Create Entrance
      this.currentCell.walls[1] = false;
      this.currentCell.createDoor(1);

      // Create Exit
      this.grid[this.gridSize - 1][this.gridSize - 1].walls[0] = false;
      this.grid[this.gridSize - 1][this.gridSize - 1].createDoor(0);

      this.metadata = {
        creator: "@daarfi",
        description: "A maze generated using the Hunt and Kill algorithm",
        createMazePerformance: 0,
        spawnMazePerformance: 0,
      };

      let t0 = performance.now();
      this.createMaze();
      let t1 = performance.now();
      console.log("Call to createMaze took " + (t1 - t0) + " milliseconds.");
      this.metadata.createMazePerformance = t1 - t0;

      t0 = performance.now();
      this.spawnMaze();
      t1 = performance.now();
      console.log("Call to spawnMaze took " + (t1 - t0) + " milliseconds.");
      this.metadata.spawnMazePerformance = t1 - t0;

      this.createInfoLabel();
    }

    // Creates cell objects and adds them to the grid array
    createGrid() {
      let rows = this.gridSize;
      let cols = this.gridSize;
      for (let y = 0; y < rows; y++) {
        this.grid.push([]);
        for (let x = 0; x < cols; x++) {
          this.grid[y].push(new Cell(y, x));
        }
      }
    }

    createMaze() {
      while (this.currentCell) {
        this.huntAndKill();
      }
    }

    // Implements hunt and kill algorithm to create a maze
    huntAndKill() {
      // Get unvisited neighbors of the current cell
      const unvisitedNeighbors = this.getCellNeighbors(this.currentCell).filter(
        (cell) => !cell.visited,
      );

      // If there are unvisited neighbors, choose one at random and remove the wall between it and the current cell
      const randomNeighbor =
        unvisitedNeighbors[Math.floor(Math.random() * unvisitedNeighbors.length)];

      if (randomNeighbor) {
        this.linkCells(randomNeighbor, this.currentCell);

        // mark both cells as visited
        this.currentCell.visited = true;
        randomNeighbor.visited = true;

        // update current cell
        this.currentCell = randomNeighbor;
      } else {
        // We go hunting
        this.currentCell = null;

        // Loop through the grid until we find an unvisited cell with a visited neighbor
        for (let row of this.grid) {
          for (let cell of row) {
            const visitedNeighbors = this.getCellNeighbors(cell).filter((cell) => cell.visited);

            if (cell.visited === false && visitedNeighbors.length > 0) {
              this.currentCell = cell;

              // Choose a random visited neighbor and remove the wall between it and the current cell
              const randomVisitedNeighbor =
                visitedNeighbors[Math.floor(Math.random() * visitedNeighbors.length)];
              this.linkCells(randomVisitedNeighbor, this.currentCell);
              cell.visited = true;
              return;
            }
          }
        }
      }
    }

    // Removes the wall between two cells
    linkCells(cellA, cellB) {
      const rowDiff = cellB.row - cellA.row;
      const colDiff = cellB.column - cellA.column;

      if (rowDiff === 1) {
        cellA.walls[0] = false;
        cellB.walls[2] = false;
      } else if (rowDiff === -1) {
        cellA.walls[2] = false;
        cellB.walls[0] = false;
      } else if (colDiff === 1) {
        cellA.walls[3] = false;
        cellB.walls[1] = false;
      } else if (colDiff === -1) {
        cellA.walls[1] = false;
        cellB.walls[3] = false;
      }
    }

    getCellNeighbors(cell) {
      const neighbors = [];
      for (let i = 0; i < directions.length; i++) {
        const neighborRow = cell.row + directions[i][0];
        const neighborCol = cell.column + directions[i][1];

        if (
          neighborRow >= 0 &&
          neighborRow < this.gridSize &&
          neighborCol >= 0 &&
          neighborCol < this.gridSize
        ) {
          neighbors.push(this.grid[neighborRow][neighborCol]);
        }
      }
      return neighbors;
    }

    // Create objects for each cell in the grid
    spawnMaze() {
      for (let y = 0; y < this.grid.length; y++) {
        for (let x = 0; x < this.grid[y].length; x++) {
          // this.grid[y][x].spawnCellLabel();
          this.grid[y][x].spawnCellWalls();
        }
      }
    }

    printMaze() {
      let row = "";
      for (let y = 0; y < this.grid.length; y++) {
        for (let x = 0; x < this.grid[y].length; x++) {
          row += `| ${this.grid[y][x].walls} |`;
        }
        row += "\n";
      }
      console.log(row);
    }

    createInfoLabel() {
      const entranceNeighborCell = this.grid[1][0];
      const labelWidth = 3;
      const labelHeight = 2;

      const label = document.createElement("m-label");
      label.setAttribute(
        "x",
        entranceNeighborCell.position.x - 0.5 * Cell.cellSize - Cell.wallDepth - 0.1,
      );
      label.setAttribute(
        "y",
        entranceNeighborCell.position.y + Math.max(0.5 * Cell.wallHeight, 0.5 + labelHeight / 2),
      );
      label.setAttribute("z", entranceNeighborCell.position.z + (labelWidth - Cell.cellSize) / 2);

      label.setAttribute(
        "content",
        `${this.metadata.creator}'s procedural maze\n${
          this.metadata.description
        }\n\nPerformance Stats:\nMaze Creation: ${this.metadata.createMazePerformance.toFixed(
          2,
        )} ms\nSpawn Maze: ${this.metadata.spawnMazePerformance.toFixed(2)} ms
        `,
      );
      label.setAttribute("width", "3");
      label.setAttribute("height", "2");
      label.setAttribute("rx", "0");
      label.setAttribute("ry", "-90");

      label.setAttribute("font-size", "16");
      label.setAttribute("alignment", "center");

      mazeContainer.appendChild(label);
    }

    createPositionProbe() {
      this.probe = document.createElement("m-position-probe");

      this.probe.setAttribute("id", "maze-position-probe");
      this.probe.setAttribute("x", (this.gridSize * Cell.cellSize) / 2);
      this.probe.setAttribute("y", 0);
      this.probe.setAttribute("z", (this.gridSize * Cell.cellSize) / 2);
      this.probe.setAttribute("range", this.getMazeRadius());
      this.probe.setAttribute("interval", "1000");
      this.probe.setAttribute("debug", "true");

      mazeContainer.appendChild(this.probe);
    }

    getMazeRadius() {
      return this.grid.length * Cell.cellSize;
    }
  }

  const maze = new Maze();

  function openDoor(doorId) {
    const [row, column, wallIndex] = doorId.split(":").map((x) => parseInt(x));
    maze.grid[row][column].doors[doorId].openDoor();
  }
</script>
