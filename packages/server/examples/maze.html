<m-group id="maze"> </m-group>

<script>
  const mazeContainer = document.getElementById("maze");
  const defaultDoorSound = "https://files.daarfi.me/brick-door-sound.mp3";
  const DOOR_LABELS = true;
  const REFRESH_INTERVAL = null;//30 * 60 * 1000; // 30 minutes

  const directions = [
    [1, 0],
    [0, -1],
    [-1, 0],
    [0, 1],
  ];

  class Door {
    constructor(cell, wallIndex) {
      this.cell = cell;
      this.wallIndex = wallIndex;
      this.id = `${cell.row}:${cell.column}:${wallIndex}`;

      this.texturedAssetMetadata = {
        width: 3,
        height: 4,
        depth: 1,
      };

      this.createTexturedDoor();
      if (DOOR_LABELS) this.createDoorLabel();

      // Create sound tag
      this.audio = document.createElement("m-audio");
      this.audio.setAttribute("src", defaultDoorSound);
      this.audio.setAttribute("volume", "0.75");
      this.audio.setAttribute("autoplay", "false");
      this.audio.setAttribute("loop", "false");
      this.audio.setAttribute("enabled", "false");
      this.audio.setAttribute("debug", "false");

      this.doorElement.appendChild(this.audio);
      mazeContainer.appendChild(this.doorElement);

      this.setupPositionProbe();
      this.state = {
        animationInterval: null,
      };
    }

    createCubeDoor() {
      this.doorElement = document.createElement("m-cube");

      const width = this.wallIndex % 2 === 0 ? Cell.cellSize + Cell.wallWidth / 2 : Cell.wallWidth;
      const depth = this.wallIndex % 2 !== 0 ? Cell.cellSize + Cell.wallDepth / 2 : Cell.wallDepth;

      const offset = directions[this.wallIndex];
      const x = this.cell.position.x + offset[1] * (Cell.cellSize / 2 + Cell.wallWidth / 2);
      const z = this.cell.position.z + offset[0] * (Cell.cellSize / 2 + Cell.wallDepth / 2);

      this.doorElement.setAttribute("id", this.id);
      this.doorElement.setAttribute("width", width);
      this.doorElement.setAttribute("height", Cell.wallHeight + 0.001);
      this.doorElement.setAttribute("depth", depth);

      this.y = this.cell.position.y + Cell.wallHeight / 2;
      this.doorElement.setAttribute("x", x);
      this.doorElement.setAttribute("y", this.y);
      this.doorElement.setAttribute("z", z);

      this.doorHeight = Cell.wallHeight;
      this.doorElement.setAttribute("color", "#000000");
    }

    createTexturedDoor() {
      this.doorElement = document.createElement("m-model");
      this.doorElement.setAttribute("id", this.id);
      this.doorElement.setAttribute("src", "https://files.daarfi.me/door.glb");

      const offset = directions[this.wallIndex];
      const x = this.cell.position.x + offset[1] * (Cell.cellSize / 2 + Cell.wallWidth / 2);
      const z = this.cell.position.z + offset[0] * (Cell.cellSize / 2 + Cell.wallDepth / 2);

      this.y = 0;
      this.doorHeight = 4;
      this.doorElement.setAttribute("x", x);
      this.doorElement.setAttribute("y", this.y);
      this.doorElement.setAttribute("z", z);

      // Scale width and height to match Cell and wall dimensions
      this.doorElement.setAttribute("sx", Cell.cellSize / this.texturedAssetMetadata.width);
      this.doorElement.setAttribute("sy", Cell.wallHeight / this.texturedAssetMetadata.height);

      this.doorElement.setAttribute("ry", this.wallIndex * 90);
    }

    setupPositionProbe() {
      // Create position probe
      this.probe = document.createElement("m-position-probe");
      this.probe.setAttribute("id", `${this.id}-probe`);
      this.probe.setAttribute("x", this.doorElement.getAttribute("x"));
      this.probe.setAttribute("y", this.doorElement.getAttribute("y"));
      this.probe.setAttribute("z", this.doorElement.getAttribute("z"));
      this.probe.setAttribute("range", Cell.cellSize);
      this.probe.setAttribute("interval", "200");
      this.probe.setAttribute("debug", "false");
      this.doorElement.parentNode.appendChild(this.probe);

      // Handle events
      this.probe.addEventListener("positionenter", (event) => {
        this.openDoor();
      });

      this.probe.addEventListener("positionleave", (event) => {
        this.closeDoor();
      });
    }

    clearAnimationInterval() {
      if (this.state.animationInterval) {
        clearInterval(this.state.animationInterval);
        this.state.animationInterval = null;
        this.audio.setAttribute("enabled", "false");
        // this.audio.setAttribute("pause-time", "0");
      }
    }

    openDoor(closeAutomatically = false) {
      const y = this.y;
      this.clearAnimationInterval();
      const doorAudio = this.audio;
      doorAudio.setAttribute("enabled", "true");
      doorAudio.setAttribute("start-time", document.timeline.currentTime);

      this.state.animationInterval = setInterval(() => {
        const newY = parseFloat(this.doorElement.getAttribute("y")) - 0.2;
        this.doorElement.setAttribute("y", newY);
        if (newY <= -1 * this.doorHeight) {
          this.clearAnimationInterval();
          if (closeAutomatically) {
            setTimeout(() => {
              this.closeDoor();
            }, 1000);
          }
        }
      }, 100);
    }

    closeDoor() {
      const y = this.y;
      const doorAudio = this.audio;
      this.clearAnimationInterval();
      doorAudio.setAttribute("enabled", "true");
      doorAudio.setAttribute("start-time", document.timeline.currentTime);

      this.state.animationInterval = setInterval(() => {
        const newY = parseFloat(this.doorElement.getAttribute("y")) + 0.2;
        this.doorElement.setAttribute("y", newY);
        if (newY >= y) {
          if (newY > y) {
            this.doorElement.setAttribute("y", y);
          }
          this.clearAnimationInterval();
        }
      }, 100);
    }

    createDoorLabel() {
      const label = document.createElement("m-label");
      const offset = directions[this.wallIndex];
      label.setAttribute("x", 0);
      label.setAttribute("y", this.texturedAssetMetadata.height / 2);
      label.setAttribute("z", (this.wallIndex % 2 === 0 ? offset[0] : offset[1]) * 0.26);
      label.setAttribute("content", "Open");
      label.setAttribute("width", "1");
      label.setAttribute("height", ".5");
      label.setAttribute("rx", "0");
      // label.setAttribute(
      //   "ry",
      //   `${this.wallIndex % 2 === 0 ? (this.wallIndex === 0 ? 0 : 1) * 180 : offset[1] * 90}`,
      // );

      // label.setAttribute('color', '#525c6a');
      // label.setAttribute('font-color', '#ffffff');
      label.setAttribute(
        "ry",
        `${this.wallIndex % 2 === 0 ? offset[1] * -90 : 180 * this.wallIndex}`,
      );

      label.setAttribute("onclick", `openDoor("${this.id}", true)`);
      this.doorElement.appendChild(label);
    }
  }

  class Cell {
    static cellSize = 3;
    static wallWidth = 0.5;
    static wallDepth = 0.5;
    static wallHeight = 4;

    constructor(row, column) {
      this.row = row;
      this.column = column;
      this.walls = [true, true, true, true];
      this.visited = false;
      this.position = Cell.getPosition(row, column);

      this.texturedAssetMetadata = {
        width: 2,
        depth: 0.5,
        height: 3,
      };

      this.doors = {};
      this.wallElements = {};
    }

    // returns the position of the center of the cell in the world
    static getPosition(row, col) {
      return {
        x: ((2 * col + 1) * Cell.cellSize) / 2 + col * Cell.wallWidth,
        y: 0,
        z: ((2 * row + 1) * Cell.cellSize) / 2 + row * Cell.wallDepth,
      };
    }

    spawnCellWalls() {
      const colors = ["red", "green", "blue", "yellow"];
      for (let i = 0; i < 4; i++) {
        if (this.walls[i]) {
          const ground = this.createTexturedGround();
          mazeContainer.appendChild(ground);

          const wall = this.createTexturedWall(i);
          this.wallElements[i] = wall;
          wall && mazeContainer.appendChild(wall);
        }
      }
    }

    createCubeWall(i) {
      const wall = document.createElement("m-cube");
      wall.setAttribute(
        "x",
        this.position.x +
          (directions[i][1] * Cell.cellSize) / 2 +
          (directions[i][1] * Cell.wallWidth) / 2,
      );
      wall.setAttribute("y", Cell.wallHeight / 2);
      wall.setAttribute(
        "z",
        this.position.z +
          (directions[i][0] * Cell.cellSize) / 2 +
          (directions[i][0] * Cell.wallDepth) / 2,
      );

      wall.setAttribute("color", "gray");

      wall.setAttribute(
        "sx",
        directions[i][1] === 0 ? Cell.cellSize + Cell.wallWidth : Cell.wallWidth,
      );
      wall.setAttribute("sy", Cell.wallHeight);
      wall.setAttribute(
        "sz",
        directions[i][0] === 0 ? Cell.cellSize + Cell.wallDepth : Cell.wallDepth,
      );

      return wall;
    }

    createTexturedWall(i) {
      const wall = document.createElement("m-model");
      wall.setAttribute("src", "https://files.daarfi.me/cobblestone-wall.glb");

      const outerWallOffset = this.isOuterWall(i) ? 0.02 : 0;
      const xOffset =
        (i < 2 ? Math.random() * 0.01 : Math.random() * -0.01) + directions[i][1] * outerWallOffset;
      const zOffset =
        (i < 2 ? Math.random() * -0.01 : Math.random() * 0.01) + directions[i][0] * outerWallOffset;
      const yOffset = Math.random() * 0.01;

      const baseX =
        this.position.x +
        (directions[i][1] * Cell.cellSize) / 2 +
        (directions[i][1] * Cell.wallWidth) / 2;
      const baseZ =
        this.position.z +
        (directions[i][0] * Cell.cellSize) / 2 +
        (directions[i][0] * Cell.wallDepth) / 2;

      wall.setAttribute("x", baseX + xOffset);
      wall.setAttribute("y", yOffset);
      wall.setAttribute("z", baseZ + zOffset);

      wall.setAttribute("ry", i * 90);

      wall.setAttribute(
        "sx",
        (Cell.cellSize + 2 * Cell.wallDepth) / this.texturedAssetMetadata.width,
      );

      wall.setAttribute("sy", 2);

      // Add wall to wall map
      // Don't add walls that overlap each other
      if (this.maze) {
        const wallKey = `${baseX}:${baseZ}`;
        if (this.maze.wallMap[wallKey]) {
          return null;
        }
        this.maze.wallMap[wallKey] = wall;
      }

      return wall;
    }

    isOuterWall(wallIndex) {
      const isTopRow = this.row === this.maze.gridSize - 1 && wallIndex === 0;
      const isLeftColumn = this.column === 0 && wallIndex === 1;
      const isBottomRow = this.row === 0 && wallIndex === 2;

      const isRightColumn = this.column === this.maze.gridSize - 1 && wallIndex === 3;
      return isBottomRow || isTopRow || isLeftColumn || isRightColumn;
    }

    createTexturedGround() {
      const ground = document.createElement("m-model");
      ground.setAttribute("src", "https://files.daarfi.me/cobblestone-ground.glb");

      ground.setAttribute("x", this.position.x);
      ground.setAttribute("y", Math.random() * 0.01);
      ground.setAttribute("z", this.position.z);

      const groundSide = 2;
      // scale ground to fit cell size
      ground.setAttribute("sx", (Cell.cellSize + 2 * Cell.wallDepth) / groundSide);
      ground.setAttribute("sz", (Cell.cellSize + 2 * Cell.wallDepth) / groundSide);
      return ground;
    }

    spawnCellLabel() {
      const label = document.createElement("m-label");
      label.setAttribute("x", this.position.x);
      label.setAttribute("y", this.position.y + 0.1);
      label.setAttribute("z", this.position.z);
      label.setAttribute("content", `(y:${this.row}, x: ${this.column})`);
      label.setAttribute("width", "2");
      label.setAttribute("rx", "-90");
      mazeContainer.appendChild(label);
    }

    createDoor(wallIndex) {
      this.walls[wallIndex] = false;
      const door = new Door(this, wallIndex);
      this.doors[door.id] = door;
    }

    setMaze(maze) {
      this.maze = maze;
    }

    resetCell() {
      this.visited = false;
      this.walls = [true, true, true, true];

      // Remove all doors
      for (const doorId in this.doors) {
        if (this.doors.hasOwnProperty(doorId)) {
          const door = this.doors[doorId];

          // Remove position probe
          mazeContainer?.removeChild(door.probe);

          // Remove door
          mazeContainer?.removeChild(door.doorElement);

          this.doors[doorId] = null;
        }
      }
      this.doors = {};

      // Remove all walls
      for (let i = 0; i < 4; i++) {
        const wall = this.wallElements[i];
        if (wall) {
          wall.parentNode?.removeChild(wall);
          this.wallElements[i] = null;
        }
      }
    }
  }

  class Maze {
    constructor() {
      this.gridSize = 4;
      this.grid = [];
      this.playerCount = 0;
      this.createGrid();
      this.createPositionProbe();

      this.currentCell = this.grid[0][0];

      // Create Entrance
      this.currentCell.walls[1] = false;
      this.currentCell.createDoor(1);

      // Create Exit
      this.grid[this.gridSize - 1][this.gridSize - 1].walls[0] = false;
      this.grid[this.gridSize - 1][this.gridSize - 1].createDoor(0);

      this.metadata = {
        creator: "@daarfi",
        description: "A maze generated using the Hunt and Kill algorithm",
        createMazePerformance: 0,
        spawnMazePerformance: 0,
      };

      // Maps coords to walls
      // Used to avoid creating multiple walls in the same coords
      this.wallMap = {};

      let t0 = performance.now();
      this.createMaze();
      let t1 = performance.now();
      console.log("Call to createMaze took " + (t1 - t0) + " milliseconds.");
      this.metadata.createMazePerformance = t1 - t0;

      t0 = performance.now();
      this.spawnMaze();
      t1 = performance.now();
      console.log("Call to spawnMaze took " + (t1 - t0) + " milliseconds.");
      this.metadata.spawnMazePerformance = t1 - t0;

      // maps player connection id to boolean indicating if player is inside maze
      this.players = {};
      this.playerCount = 0;

      this.watchPlayers();
      this.jumbotron = new Jumbotron(this);
      this.createInfoLabel();

      if (REFRESH_INTERVAL) {
        this.nextUpdate = Date.now() + REFRESH_INTERVAL;
        setInterval(() => {
          this.refreshMaze();
          this.nextUpdate = Date.now() + REFRESH_INTERVAL;
        }, REFRESH_INTERVAL);

        // Update jumbotron
        setInterval(() => {
          this.jumbotron.updateLabels();
        }, 1000);
      }
    }

    // Creates cell objects and adds them to the grid array
    createGrid() {
      let rows = this.gridSize;
      let cols = this.gridSize;
      for (let y = 0; y < rows; y++) {
        this.grid.push([]);
        for (let x = 0; x < cols; x++) {
          this.grid[y].push(new Cell(y, x));
        }
      }
    }

    createMaze() {
      while (this.currentCell) {
        this.huntAndKill();
      }
    }

    // Implements hunt and kill algorithm to create a maze
    huntAndKill() {
      // Get unvisited neighbors of the current cell
      const unvisitedNeighbors = this.getCellNeighbors(this.currentCell).filter(
        (cell) => !cell.visited,
      );

      // If there are unvisited neighbors, choose one at random and remove the wall between it and the current cell
      const randomNeighbor =
        unvisitedNeighbors[Math.floor(Math.random() * unvisitedNeighbors.length)];

      if (randomNeighbor) {
        this.linkCells(randomNeighbor, this.currentCell);

        // mark both cells as visited
        this.currentCell.visited = true;
        randomNeighbor.visited = true;

        // update current cell
        this.currentCell = randomNeighbor;
      } else {
        // We go hunting
        this.currentCell = null;

        // Loop through the grid until we find an unvisited cell with a visited neighbor
        for (let row of this.grid) {
          for (let cell of row) {
            const visitedNeighbors = this.getCellNeighbors(cell).filter((cell) => cell.visited);

            if (cell.visited === false && visitedNeighbors.length > 0) {
              this.currentCell = cell;

              // Choose a random visited neighbor and remove the wall between it and the current cell
              const randomVisitedNeighbor =
                visitedNeighbors[Math.floor(Math.random() * visitedNeighbors.length)];
              this.linkCells(randomVisitedNeighbor, this.currentCell);
              cell.visited = true;
              return;
            }
          }
        }
      }
    }

    // Removes the wall between two cells
    linkCells(cellA, cellB) {
      const rowDiff = cellB.row - cellA.row;
      const colDiff = cellB.column - cellA.column;

      if (rowDiff === 1) {
        cellA.walls[0] = false;
        cellB.walls[2] = false;
      } else if (rowDiff === -1) {
        cellA.walls[2] = false;
        cellB.walls[0] = false;
      } else if (colDiff === 1) {
        cellA.walls[3] = false;
        cellB.walls[1] = false;
      } else if (colDiff === -1) {
        cellA.walls[1] = false;
        cellB.walls[3] = false;
      }
    }

    getCellNeighbors(cell) {
      const neighbors = [];
      for (let i = 0; i < directions.length; i++) {
        const neighborRow = cell.row + directions[i][0];
        const neighborCol = cell.column + directions[i][1];

        if (
          neighborRow >= 0 &&
          neighborRow < this.gridSize &&
          neighborCol >= 0 &&
          neighborCol < this.gridSize
        ) {
          neighbors.push(this.grid[neighborRow][neighborCol]);
        }
      }
      return neighbors;
    }

    // Create objects for each cell in the grid
    spawnMaze() {
      for (let y = 0; y < this.grid.length; y++) {
        for (let x = 0; x < this.grid[y].length; x++) {
          // this.grid[y][x].spawnCellLabel();
          this.grid[y][x].setMaze(this);
          this.grid[y][x].spawnCellWalls();
        }
      }
    }

    printMaze() {
      let row = "";
      for (let y = 0; y < this.grid.length; y++) {
        for (let x = 0; x < this.grid[y].length; x++) {
          row += `| ${this.grid[y][x].walls} |`;
        }
        row += "\n";
      }
      console.log(row);
    }

    createInfoLabel() {
      const entranceNeighborCell = this.grid[1][0];
      const labelWidth = 3;
      const labelHeight = 2;

      const label = document.createElement("m-label");
      label.setAttribute(
        "x",
        entranceNeighborCell.position.x - 0.5 * Cell.cellSize - Cell.wallDepth - 0.1,
      );
      label.setAttribute(
        "y",
        entranceNeighborCell.position.y + Math.max(0.5 * Cell.wallHeight, 0.5 + labelHeight / 2),
      );
      label.setAttribute("z", entranceNeighborCell.position.z + (labelWidth - Cell.cellSize) / 2);

      label.setAttribute(
        "content",
        `${this.metadata.creator}'s procedural maze\n${
          this.metadata.description
        }\n\nPerformance Stats:\nMaze Creation: ${this.metadata.createMazePerformance.toFixed(
          2,
        )} ms\nSpawn Maze: ${this.metadata.spawnMazePerformance.toFixed(2)} ms
        `,
      );
      label.setAttribute("width", "3");
      label.setAttribute("height", "2");
      label.setAttribute("rx", "0");
      label.setAttribute("ry", "-90");

      label.setAttribute("font-size", "16");
      label.setAttribute("alignment", "center");

      mazeContainer.appendChild(label);
    }

    createPositionProbe() {
      this.probe = document.createElement("m-position-probe");
      const { x, z } = this.getMazeCenter();
      this.probe.setAttribute("id", "maze-position-probe");
      this.probe.setAttribute("x", x);
      this.probe.setAttribute("y", 0);
      this.probe.setAttribute("z", z);
      this.probe.setAttribute("range", this.getMazeRadius());
      this.probe.setAttribute("interval", "500");
      this.probe.setAttribute("debug", "false");
      mazeContainer.appendChild(this.probe);
    }

    getMazeRadius() {
      return this.grid.length * Cell.cellSize;
    }

    getMazeCenter() {
      return {
        x: this.getMazeRadius() / 2,
        y: 0,
        z: this.getMazeRadius() / 2,
      };
    }

    watchPlayers() {
      this.probe.addEventListener("positionmove", (event) => {
        const { connectionId, elementRelative, documentRelative } = event.detail;
        const prevPlayerCount = this.playerCount;
        const isPlayerInside = this.checkBounds(
          documentRelative.position.x,
          documentRelative.position.z,
        );
        if (connectionId in this.players) {
          const prevValue = this.players[connectionId];
          if (prevValue !== isPlayerInside) {
            this.players[connectionId] = isPlayerInside;
            if (isPlayerInside) {
              this.playerCount++;
            } else {
              this.playerCount--;
            }
          }
        } else {
          this.players[connectionId] = isPlayerInside;
          if (isPlayerInside) {
            this.playerCount++;
          }
        }

        this.playerCount !== prevPlayerCount && this.jumbotron.updateLabels();
      });
    }

    checkBounds(x, z) {
      const lowerBound = 0;
      // note: this assumes that the maze is a square
      const upperBound =
        this.grid[this.grid.length - 1][this.grid.length - 1].position.x + Cell.cellSize / 2;
      if (x < lowerBound || x >= upperBound || z < lowerBound || z >= upperBound) {
        return false;
      } else {
        return true;
      }
    }

    refreshMaze() {
      this.wallMap = {};

      // Reset grid
      for (let y = 0; y < this.grid.length; y++) {
        for (let x = 0; x < this.grid[y].length; x++) {
          this.grid[y][x].resetCell();
        }
      }

      this.currentCell = this.grid[0][0];

      // Create Entrance
      this.currentCell.walls[1] = false;
      this.currentCell.createDoor(1);

      // Create Exit
      this.grid[this.gridSize - 1][this.gridSize - 1].walls[0] = false;
      this.grid[this.gridSize - 1][this.gridSize - 1].createDoor(0);

      let t0 = performance.now();
      this.createMaze();
      let t1 = performance.now();
      console.log("Call to createMaze took " + (t1 - t0) + " milliseconds.");
      this.metadata.createMazePerformance = t1 - t0;

      t0 = performance.now();
      this.spawnMaze();
      t1 = performance.now();
      console.log("Call to spawnMaze took " + (t1 - t0) + " milliseconds.");
      this.metadata.spawnMazePerformance = t1 - t0;
    }
  }

  class Jumbotron {
    constructor(maze) {
      this.maze = maze;
      this.positionProbe = maze.probe;

      this.width = 12;
      this.height = 6;
      this.depth = 12;

      this.createTexturedJumbo();
      mazeContainer.appendChild(this.jumbotron);

      this.labels = [];
      this.createLabel();
    }

    createCubeJumbo() {
      this.jumbotron = document.createElement("m-cube");
      this.jumbotron.setAttribute("id", "maze-jumbotron");
      this.jumbotron.setAttribute("width", `${this.width}`);
      this.jumbotron.setAttribute("height", `${this.height}`);
      this.jumbotron.setAttribute("depth", `${this.depth}`);
      this.jumbotron.setAttribute("color", "#0000ff");

      this.jumbotron.setAttribute("x", this.positionProbe.getAttribute("x"));
      this.jumbotron.setAttribute("y", 15);
      this.jumbotron.setAttribute("z", this.positionProbe.getAttribute("z"));

      this.labelOffset = 0;
    }

    createTexturedJumbo() {
      this.jumbotron = document.createElement("m-model");
      this.jumbotron.setAttribute("id", "maze-jumbotron");
      this.jumbotron.setAttribute("src", "https://files.daarfi.me/jumbo.glb");

      this.jumbotron.setAttribute("x", this.positionProbe.getAttribute("x"));
      this.jumbotron.setAttribute("y", 15);
      this.jumbotron.setAttribute("z", this.positionProbe.getAttribute("z"));

      this.labelOffset = 2;
    }

    createLabel() {
      const offset = 0.01;
      const sides = [
        [this.width / 2 + offset, 0],
        [0, this.depth / 2 + offset],
        [-this.width / 2 - offset, 0],
        [0, -this.depth / 2 - offset],
      ];
      const bezel = 2;
      const labels = [];
      for (let i = 0; i < sides.length; i++) {
        const [x, z] = sides[i];

        const label = document.createElement("m-label");
        label.setAttribute("id", `jumbotron-label-${i}`);
        label.setAttribute("x", x);
        label.setAttribute("y", this.labelOffset + bezel / 2);
        label.setAttribute("z", z);
        label.setAttribute("content", "");
        label.setAttribute("width", this.width - bezel);
        label.setAttribute("height", this.height - bezel);
        label.setAttribute("rx", "0");

        label.setAttribute("ry", -90 + i * 90 + (i % 2 === 0 ? 180 : 0));
        label.setAttribute("font-size", "64");
        label.setAttribute("alignment", "center");

        this.jumbotron.appendChild(label);
        labels.push(label);
      }

      this.labels = labels;
      this.updateLabels();
    }

    updateLabels() {
      const content = `Players: ${this.maze.playerCount}\n${this.maze.nextUpdate ? `Time Remaining: ${((this.maze.nextUpdate - Date.now()) / 1000).toFixed(0)}s` : ''}`;
      for (let i = 0; i < this.labels.length; i++) {
        this.labels[i].setAttribute("content", content);
      }
    }
  }

  const maze = new Maze();

  function openDoor(doorId, closeAutomatically = false) {
    const [row, column, wallIndex] = doorId.split(":").map((x) => parseInt(x));
    maze.grid[row][column].doors[doorId].openDoor(closeAutomatically);
  }
</script>
